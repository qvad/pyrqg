"""
Concurrent Isolation Testing Grammar for PostgreSQL
Tests transaction isolation levels, locking, MVCC, deadlocks, and concurrency edge cases
"""

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

from pyrqg.dsl.core import Grammar, choice, template, ref, number, maybe
import psycopg2

# Get real database schema for isolation testing
def get_test_schema():
    """Fetch tables suitable for concurrency testing"""
    try:
        conn = psycopg2.connect("dbname=postgres")
        cur = conn.cursor()
        
        # Get tables with numeric columns (for increment operations)
        cur.execute("""
            SELECT DISTINCT 
                t.table_name,
                array_agg(c.column_name) FILTER (WHERE c.data_type IN ('integer', 'bigint', 'numeric')) as numeric_cols,
                array_agg(c.column_name) FILTER (WHERE c.data_type IN ('character varying', 'text')) as text_cols
            FROM information_schema.tables t
            JOIN information_schema.columns c ON t.table_name = c.table_name
            WHERE t.table_schema = 'public' 
            AND t.table_type = 'BASE TABLE'
            AND t.table_name NOT LIKE 'table_%'
            GROUP BY t.table_name
            HAVING COUNT(c.column_name) > 2
            LIMIT 10
        """)
        
        tables_info = []
        for table, num_cols, text_cols in cur.fetchall():
            tables_info.append({
                'table': table,
                'numeric_columns': num_cols or ['id'],
                'text_columns': text_cols or ['name']
            })
        
        # Get tables with foreign key relationships
        cur.execute("""
            SELECT DISTINCT
                tc.table_name as child_table,
                kcu.column_name as fk_column,
                ccu.table_name as parent_table,
                ccu.column_name as parent_column
            FROM information_schema.table_constraints tc
            JOIN information_schema.key_column_usage kcu 
                ON tc.constraint_name = kcu.constraint_name
            JOIN information_schema.constraint_column_usage ccu 
                ON ccu.constraint_name = tc.constraint_name
            WHERE tc.constraint_type = 'FOREIGN KEY'
            AND tc.table_schema = 'public'
            LIMIT 5
        """)
        
        fk_relationships = [row for row in cur.fetchall()]
        
        cur.close()
        conn.close()
        
        return tables_info, fk_relationships
    except:
        # Fallback
        return (
            [
                {'table': 'users', 'numeric_columns': ['id'], 'text_columns': ['name']},
                {'table': 'products', 'numeric_columns': ['id', 'price'], 'text_columns': ['name']},
                {'table': 'orders', 'numeric_columns': ['id', 'quantity'], 'text_columns': []}
            ],
            []
        )

tables_info, fk_relationships = get_test_schema()

# Extract useful values
tables = [t['table'] for t in tables_info]
numeric_columns = []
for t in tables_info:
    numeric_columns.extend(t['numeric_columns'])
numeric_columns = list(set(numeric_columns))

# Ensure we have some values
if not tables:
    tables = ["users", "products", "orders"]
if not numeric_columns:
    numeric_columns = ["id", "quantity", "price"]

g = Grammar("concurrent_isolation_testing")

# Main concurrency test patterns
g.rule("query",
    choice(
        ref("isolation_level_tests"),
        ref("locking_tests"),
        ref("mvcc_tests"),
        ref("deadlock_scenarios"),
        ref("race_condition_tests"),
        ref("serialization_anomalies"),
        weights=[20, 20, 15, 15, 15, 15]
    )
)

# Transaction isolation level tests
g.rule("isolation_level_tests",
    choice(
        # Read uncommitted phantom reads
        template("""-- READ UNCOMMITTED phantom read test
BEGIN ISOLATION LEVEL READ UNCOMMITTED;
SELECT COUNT(*) FROM {table} WHERE {numeric_column} > 0;
-- Another transaction would INSERT here
SELECT COUNT(*) FROM {table} WHERE {numeric_column} > 0;
COMMIT;"""),
        
        # Read committed non-repeatable read
        template("""-- READ COMMITTED non-repeatable read test
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT {numeric_column} FROM {table} WHERE {pk_column} = 1;
-- Another transaction would UPDATE here
SELECT {numeric_column} FROM {table} WHERE {pk_column} = 1;
COMMIT;"""),
        
        # Repeatable read phantom
        template("""-- REPEATABLE READ phantom read test
BEGIN ISOLATION LEVEL REPEATABLE READ;
-- Snapshot taken here
SELECT COUNT(*) FROM {table} WHERE {numeric_column} BETWEEN 1 AND 100;
-- Another transaction INSERTs in range
SELECT COUNT(*) FROM {table} WHERE {numeric_column} BETWEEN 1 AND 100;
COMMIT;"""),
        
        # Serializable test
        template("""-- SERIALIZABLE isolation test
BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT SUM({numeric_column}) FROM {table};
UPDATE {table} SET {numeric_column} = {numeric_column} + 1 WHERE {pk_column} = 1;
COMMIT;""")
    )
)

# Locking mechanism tests
g.rule("locking_tests",
    choice(
        # Row-level locking
        template("""-- Row-level lock test
BEGIN;
SELECT * FROM {table} WHERE {pk_column} = 1 FOR UPDATE;
UPDATE {table} SET {numeric_column} = {numeric_column} + 1 WHERE {pk_column} = 1;
COMMIT;"""),
        
        # Shared locks
        template("""-- Shared lock test
BEGIN;
SELECT * FROM {table} WHERE {numeric_column} > 0 FOR SHARE;
-- Other transactions can read but not write
COMMIT;"""),
        
        # Nowait locking
        template("""-- NOWAIT lock test
BEGIN;
SELECT * FROM {table} WHERE {pk_column} = 1 FOR UPDATE NOWAIT;
UPDATE {table} SET {numeric_column} = {numeric_column} * 2 WHERE {pk_column} = 1;
COMMIT;"""),
        
        # Skip locked
        template("""-- SKIP LOCKED test
BEGIN;
SELECT * FROM {table} 
WHERE {numeric_column} > 0 
ORDER BY {pk_column}
FOR UPDATE SKIP LOCKED
LIMIT 1;
COMMIT;"""),
        
        # Advisory locks
        template("""-- Advisory lock test
SELECT pg_advisory_lock({lock_id});
-- Do work while holding lock
UPDATE {table} SET {numeric_column} = {numeric_column} + 1 WHERE {pk_column} = 1;
SELECT pg_advisory_unlock({lock_id});""")
    )
)

# MVCC behavior tests
g.rule("mvcc_tests",
    choice(
        # Snapshot visibility
        template("""-- MVCC snapshot test
BEGIN ISOLATION LEVEL REPEATABLE READ;
-- Take snapshot
SELECT txid_current(), COUNT(*) FROM {table};
-- Changes by other transactions not visible
SELECT COUNT(*) FROM {table};
COMMIT;"""),
        
        # Update chains
        template("""-- HOT (Heap Only Tuple) update test
-- Update non-indexed column to trigger HOT
UPDATE {table} 
SET {text_column} = {text_column} || '_updated' 
WHERE {pk_column} = 1;"""),
        
        # Vacuum visibility
        template("""-- Dead tuple visibility test
DELETE FROM {table} WHERE {pk_column} > 1000000;
-- Dead tuples still visible to older transactions
SELECT COUNT(*) FROM {table};""")
    )
)

# Deadlock scenarios
g.rule("deadlock_scenarios",
    choice(
        # Classic A-B B-A deadlock
        template("""-- Classic deadlock pattern (Transaction 1)
BEGIN;
UPDATE {table1} SET {numeric_column} = {numeric_column} + 1 WHERE {pk_column} = 1;
-- Transaction 2 would update table2 then table1
UPDATE {table2} SET {numeric_column} = {numeric_column} + 1 WHERE {pk_column} = 1;
COMMIT;"""),
        
        # Foreign key deadlock
        template("""-- Foreign key induced deadlock
BEGIN;
-- Lock parent row
SELECT * FROM {parent_table} WHERE {pk_column} = 1 FOR UPDATE;
-- Try to insert child that references locked parent
INSERT INTO {child_table} ({fk_column}) VALUES (1);
COMMIT;"""),
        
        # Index order deadlock
        template("""-- Index-order deadlock prone pattern
BEGIN;
UPDATE {table} SET {numeric_column} = {numeric_column} + 1 
WHERE {pk_column} IN (1, 2, 3)
ORDER BY {pk_column} DESC;
COMMIT;""")
    )
)

# Race condition tests
g.rule("race_condition_tests",
    choice(
        # Lost update
        template("""-- Lost update test
-- Read
SELECT {numeric_column} INTO TEMP lost_update_test FROM {table} WHERE {pk_column} = 1;
-- Modify (another transaction could update between)
UPDATE {table} 
SET {numeric_column} = (SELECT * FROM lost_update_test) + 1 
WHERE {pk_column} = 1;"""),
        
        # Check-then-act
        template("""-- Check-then-act race condition
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM {table} WHERE {pk_column} = 999) THEN
        -- Race: another transaction could insert between check and act
        INSERT INTO {table} ({pk_column}, {numeric_column}) VALUES (999, 1);
    END IF;
END $$;"""),
        
        # Read-modify-write
        template("""-- Read-modify-write with SELECT FOR UPDATE
BEGIN;
SELECT * FROM {table} WHERE {pk_column} = 1 FOR UPDATE;
UPDATE {table} 
SET {numeric_column} = {numeric_column} + 1 
WHERE {pk_column} = 1;
COMMIT;""")
    )
)

# Serialization anomaly tests
g.rule("serialization_anomalies",
    choice(
        # Write skew
        template("""-- Write skew anomaly test
BEGIN ISOLATION LEVEL SERIALIZABLE;
-- Two accounts should sum to 100
SELECT SUM({numeric_column}) FROM {table} WHERE {pk_column} IN (1, 2);
-- Withdraw from account 1
UPDATE {table} SET {numeric_column} = {numeric_column} - 10 WHERE {pk_column} = 1;
COMMIT;"""),
        
        # Read-only anomaly
        template("""-- Read-only serialization anomaly
BEGIN ISOLATION LEVEL SERIALIZABLE READ ONLY;
SELECT COUNT(*) as before FROM {table} WHERE {numeric_column} > 50;
-- Anomaly: result depends on concurrent transactions
SELECT COUNT(*) as after FROM {table} WHERE {numeric_column} > 50;
COMMIT;"""),
        
        # Predicate lock test
        template("""-- Predicate lock test
BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM {table} WHERE {numeric_column} BETWEEN 10 AND 20;
INSERT INTO {table} ({numeric_column}) VALUES (15);
COMMIT;""")
    )
)

# Table and column rules
g.rule("table", choice(*tables))
g.rule("table1", choice(*tables[:len(tables)//2]) if len(tables) > 1 else tables[0])
g.rule("table2", choice(*tables[len(tables)//2:]) if len(tables) > 1 else tables[0])

# Handle FK relationships
if fk_relationships:
    g.rule("parent_table", choice(*[fk[2] for fk in fk_relationships]))
    g.rule("child_table", choice(*[fk[0] for fk in fk_relationships]))
    g.rule("fk_column", choice(*[fk[1] for fk in fk_relationships]))
else:
    g.rule("parent_table", tables[0])
    g.rule("child_table", tables[1] if len(tables) > 1 else tables[0])
    g.rule("fk_column", "id")

# Column rules
g.rule("pk_column", "id")
g.rule("numeric_column", choice(*numeric_columns))
g.rule("text_column", choice("name", "description", "status"))

# Lock IDs for advisory locks
g.rule("lock_id", number(1, 1000))

# Export grammar
grammar = g